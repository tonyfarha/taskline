import { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import { toast } from "sonner";
import { Task } from "@/types";
import { exportToXLSX } from "@/lib/export";

export const useTaskManagement = () => {
  const { data: session, status } = useSession();
  const [tasks, setTasks] = useState<Task[]>([]);

  const fetchTasksFromDb = async () => {
    try {
      const res = await fetch("/api/tasks");
      const data = await res.json();
      setTasks(data);
    } catch (error) {
      toast.error("Failed to fetch tasks from database.");
      console.error("Failed to fetch tasks:", error);
    }
  };

  useEffect(() => {
    const fetchAndSyncTasks = async () => {
      if (status === "authenticated") {
        // Check for local storage tasks to sync
        if (typeof window !== 'undefined') {
          const savedTasks = localStorage.getItem('tasks');
          if (savedTasks) {
            const localTasks: Task[] = JSON.parse(savedTasks);
            if (localTasks.length > 0) {
              toast.info("Syncing local tasks to your account...");
              for (const task of localTasks) {
                try {
                  // Remove the id property as it will be generated by the database
                  const taskToSync = { ...task };
                  delete taskToSync.id;
                  await fetch("/api/tasks", {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify(taskToSync),
                  });
                } catch (error) {
                  console.error("Failed to sync task:", task, error);
                  toast.error("Failed to sync some local tasks.");
                }
              }
              localStorage.removeItem('tasks'); // Clear local storage after sync
              toast.success("Local tasks synced successfully!");
            }
          }
        }

        // Fetch tasks from database
        fetchTasksFromDb();
      } else if (status === "unauthenticated") {
        // Load tasks from local storage
        if (typeof window !== 'undefined') {
          const savedTasks = localStorage.getItem('tasks');
          setTasks(savedTasks ? JSON.parse(savedTasks) : []);
        }
      }
    };
    fetchAndSyncTasks();
  }, [session, status]);

  useEffect(() => {
    if (status === "unauthenticated" && typeof window !== 'undefined') {
      localStorage.setItem('tasks', JSON.stringify(tasks));
    }
  }, [tasks, status]);
  const [selectedTasks, setSelectedTasks] = useState<string[]>([]);
  const [isCreateTaskModalOpen, setCreateTaskModalOpen] = useState(false);
  const [isEditModalOpen, setEditModalOpen] = useState(false);
  const [taskToEdit, setTaskToEdit] = useState<Task | null>(null);
  const [isDeleteModalOpen, setDeleteModalOpen] = useState(false);
  const [taskToDelete, setTaskToDelete] = useState<string | null>(null);

  const handleAddTask = async (newTaskData: Omit<Task, 'id'>) => {
    const { title, description, startDate, endDate, color } = newTaskData;

    if (new Date(endDate) < new Date(startDate)) {
      toast.error("End date cannot be before start date.");
      return;
    }

    if (status === "authenticated") {
      try {
        const res = await fetch("/api/tasks", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(newTaskData),
        });
        if (res.ok) {
          const newTask = await res.json();
          setTasks((prevTasks) => [...prevTasks, newTask]);
          toast.success("Task created successfully!");
          setCreateTaskModalOpen(false);
        } else {
          toast.error("Failed to create task in database.");
        }
      } catch (error) {
        toast.error("Failed to create task.");
        console.error("Failed to create task:", error);
      }
    } else {
      const newTask: Task = {
        id: String(tasks.length + 1), // Convert to string for local storage
        title,
        description,
        startDate,
        endDate,
        color,
      };
      setTasks((prevTasks) => [...prevTasks, newTask]);
      toast.success("Task created successfully!");
      setCreateTaskModalOpen(false);
    }
  };

  const handleEditTask = async (updatedTask: Task) => {
    if (new Date(updatedTask.endDate) < new Date(updatedTask.startDate)) {
      toast.error("End date cannot be before start date.");
      return;
    }

    if (status === "authenticated") {
      try {
        const res = await fetch("/api/tasks", {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(updatedTask),
        });
        if (res.ok) {
          setTasks(tasks.map(task => task.id === updatedTask.id ? updatedTask : task));
          toast.success("Task updated successfully!");
          setEditModalOpen(false);
          setTaskToEdit(null);
        } else {
          toast.error("Failed to update task in database.");
        }
      } catch (error) {
        toast.error("Failed to update task.");
        console.error("Failed to update task:", error);
      }
    } else {
      setTasks(tasks.map(task => task.id === updatedTask.id ? updatedTask : task));
      toast.success("Task updated successfully!");
      setEditModalOpen(false);
      setTaskToEdit(null);
    }
  };

  const handleDeleteTask = async () => {
    if (taskToDelete !== null) {
      if (status === "authenticated") {
        try {
          const res = await fetch(`/api/tasks?id=${taskToDelete}`, {
            method: "DELETE",
          });
          if (res.ok) {
            toast.success("Task deleted successfully!");
            setDeleteModalOpen(false);
            setTaskToDelete(null);
            fetchTasksFromDb(); // Re-fetch tasks after successful deletion
          } else {
            toast.error("Failed to delete task from database.");
          }
        } catch (error) {
          toast.error("Failed to delete task.");
          console.error("Failed to delete task:", error);
        }
      } else {
        setTasks(tasks.filter((task) => task.id !== String(taskToDelete)));
        toast.success("Task deleted successfully!");
        setDeleteModalOpen(false);
        setTaskToDelete(null);
      }
    }
  };

  const handleExport = () => {
    const tasksToExport = tasks.filter(task => selectedTasks.includes(task.id));
    exportToXLSX(tasksToExport)
      .then(() => toast.success("TaskLine exported successfully!"))
      .catch(() => toast.error("Failed to export taskline."));
  };

  return {
    tasks,
    setTasks,
    selectedTasks,
    setSelectedTasks,
    isCreateTaskModalOpen,
    setCreateTaskModalOpen,
    isEditModalOpen,
    setEditModalOpen,
    taskToEdit,
    setTaskToEdit,
    isDeleteModalOpen,
    setDeleteModalOpen,
    taskToDelete,
    setTaskToDelete,
    handleAddTask,
    handleEditTask,
    handleDeleteTask,
    handleExport,
  };
};
